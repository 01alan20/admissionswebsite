name: Contact requests -> email

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch: {}

jobs:
  forward:
    runs-on: ubuntu-latest
    steps:
      - name: Forward new contact requests
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          GMAIL_USERNAME: ${{ secrets.GMAIL_USERNAME }}
          GMAIL_APP_PASSWORD: ${{ secrets.GMAIL_APP_PASSWORD }}
          CONTACT_EMAIL_TO: ${{ secrets.CONTACT_EMAIL_TO }}
          CONTACT_EMAIL_FROM: ${{ secrets.CONTACT_EMAIL_FROM }}
        run: |
          python - << 'PY'
          import json
          import os
          import smtplib
          import ssl
          import urllib.parse
          import urllib.request
          from email.message import EmailMessage

          STATUS_NEW = "new"
          STATUS_EMAILED = "emailed"

          def get_env(name: str) -> str:
            value = os.environ.get(name)
            if not value:
              raise RuntimeError(f"Missing required environment variable: {name}")
            return value

          SUPABASE_URL = get_env("SUPABASE_URL").rstrip("/")
          SERVICE_KEY = get_env("SUPABASE_SERVICE_ROLE_KEY")
          GMAIL_USERNAME = get_env("GMAIL_USERNAME")
          GMAIL_APP_PASSWORD = get_env("GMAIL_APP_PASSWORD")
          TO_ADDR = get_env("CONTACT_EMAIL_TO")
          FROM_ADDR = os.environ.get("CONTACT_EMAIL_FROM") or GMAIL_USERNAME

          def supabase_request(method: str, path: str, body=None):
            url = f"{SUPABASE_URL}{path}"
            headers = {
              "apikey": SERVICE_KEY,
              "Authorization": f"Bearer {SERVICE_KEY}",
              "Content-Type": "application/json",
            }
            data = None
            if body is not None:
              data = json.dumps(body).encode("utf-8")
            req = urllib.request.Request(url, data=data, headers=headers, method=method)
            with urllib.request.urlopen(req, timeout=30) as resp:
              return resp.getcode(), resp.read().decode("utf-8")

          def fetch_new_requests():
            params = urllib.parse.urlencode(
              {
                "select": "id,created_at,name,email,phone,grad_year,grade_level,interests,budget_range,location_preferences,message,source_page,user_id",
                "status": f"eq.{STATUS_NEW}",
                "order": "created_at.desc",
              }
            )
            code, text = supabase_request("GET", f"/rest/v1/contact_requests?{params}")
            if code != 200:
              raise RuntimeError(f"Supabase fetch failed: HTTP {code} {text}")
            return json.loads(text)

          def mark_as_emailed(row_id):
            params = urllib.parse.urlencode({"id": f"eq.{row_id}"})
            code, text = supabase_request("PATCH", f"/rest/v1/contact_requests?{params}", {"status": STATUS_EMAILED})
            if code not in (200, 204):
              raise RuntimeError(f"Supabase update failed for {row_id}: HTTP {code} {text}")

          def build_body(row):
            lines = [
              f"Name: {row.get('name')}",
              f"Email: {row.get('email')}",
            ]
            optional_fields = [
              ("phone", "Phone"),
              ("grad_year", "Grad year"),
              ("grade_level", "Grade level"),
              ("interests", "Interests"),
              ("budget_range", "Budget"),
              ("location_preferences", "Location preferences"),
              ("source_page", "Source page"),
              ("user_id", "User id"),
            ]
            for key, label in optional_fields:
              value = row.get(key)
              if value:
                lines.append(f"{label}: {value}")
            lines.append("")
            lines.append("Message:")
            lines.append(row.get("message") or "")
            return "\n".join(lines)

          def send_email(row):
            msg = EmailMessage()
            msg["Subject"] = "New SeeThroughAdmissions contact request"
            msg["From"] = FROM_ADDR
            msg["To"] = TO_ADDR
            msg.set_content(build_body(row))

            context = ssl.create_default_context()
            with smtplib.SMTP_SSL("smtp.gmail.com", 465, context=context) as smtp:
              smtp.login(GMAIL_USERNAME, GMAIL_APP_PASSWORD)
              smtp.send_message(msg)

          rows = fetch_new_requests()
          if not rows:
            print("No new contact requests.")
            raise SystemExit(0)

          print(f"Found {len(rows)} new contact request(s).")
          for row in rows:
            row_id = row.get("id")
            print(f"Sending request {row_id} from {row.get('name')} <{row.get('email')}>")
            send_email(row)
            mark_as_emailed(row_id)

          print("Done.")
          PY

